name: Sync Upstream Release (Only When Updated)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */6 * * *" # 每6小时检查一次；想更省就改成每天一次：0 3 * * *

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release
          fetch-depth: 0

      - name: Get upstream latest release tag
        id: upstream
        run: |
          set -e
          TAG=$(curl -s https://api.github.com/repos/MatsuriDayo/NekoBoxForAndroid/releases/latest | jq -r .tag_name)
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Upstream latest tag: $TAG"

      - name: Read current synced tag (from patched-release)
        id: current
        run: |
          set -e
          if [ -f .upstream_release_tag ]; then
            CUR=$(cat .upstream_release_tag)
          else
            CUR=""
          fi
          echo "tag=$CUR" >> $GITHUB_OUTPUT
          echo "Current tag: $CUR"

      - name: Exit if no update
        if: steps.upstream.outputs.tag == steps.current.outputs.tag
        run: echo "No new upstream release tag. Skip sync & build."

      - name: Sync upstream tag -> patched-release, then apply UI changes
        if: steps.upstream.outputs.tag != steps.current.outputs.tag
        run: |
          set -e

          git remote add upstream https://github.com/MatsuriDayo/NekoBoxForAndroid.git || true
          git fetch upstream --tags --force

          TAG="${{ steps.upstream.outputs.tag }}"
          echo "Syncing to tag: $TAG"

          # 让 patched-release 变成“上游发布版源码”
          git reset --hard "refs/tags/$TAG"

          # ====== 自动应用你的 UI 改动（稳健版）======
          python3 - <<'PY'
          import re
          from pathlib import Path

          def read(p: Path) -> str:
              return p.read_text(encoding="utf-8")

          def write(p: Path, s: str):
              p.write_text(s, encoding="utf-8")

          def remove_additem_block_containing(p: Path, needle: str, desc: str):
              s = read(p)
              i = s.find(needle)
              if i == -1:
                  raise SystemExit(f"[FAIL] {desc}: needle not found: {needle} in {p}")

              # 找到离 needle 最近的 addItem( 调用（删整块）
              call = s.rfind("addItem(", 0, i)
              if call == -1:
                  raise SystemExit(f"[FAIL] {desc}: addItem( not found before needle in {p}")

              # 从该行行首开始删除（更干净）
              line_start = s.rfind("\n", 0, call)
              line_start = 0 if line_start == -1 else line_start + 1

              # 从 addItem( 的 '(' 开始做括号配对，找到它对应的结尾 ')'
              open_idx = s.find("(", call)
              depth = 0
              end = None
              for j in range(open_idx, len(s)):
                  c = s[j]
                  if c == "(":
                      depth += 1
                  elif c == ")":
                      depth -= 1
                      if depth == 0:
                          end = j + 1
                          break
              if end is None:
                  raise SystemExit(f"[FAIL] {desc}: cannot find matching ')' for addItem( in {p}")

              new = s[:line_start] + s[end:]
              write(p, new)
              print(f"[OK] {desc}")

          def remove_menu_item(menu_xml: Path, item_id: str, desc: str):
              s = read(menu_xml)
              # 兼容多行属性 + 自闭合 <item ... />
              pat = rf"<item\b[^>]*android:id=\"@\\+id/{re.escape(item_id)}\"[^>]*/>\s*"
              new, n = re.subn(pat, "", s, flags=re.S)
              if n == 0:
                  print(f"[WARN] {desc}: not found ({item_id}) in {menu_xml}, skip")
              else:
                  write(menu_xml, new)
                  print(f"[OK] {desc}")

          def remove_when_case_block(p: Path, rid: str, desc: str):
              s = read(p)
              # 删除 `R.id.xxx -> { ... }` 整块（非贪婪）
              pat = rf"\s*R\.id\.{re.escape(rid)}\s*->\s*\{{.*?\}}\s*"
              new, n = re.subn(pat, "", s, flags=re.S)
              if n == 0:
                  print(f"[WARN] {desc}: not found (R.id.{rid}) in {p}, skip")
              else:
                  write(p, new)
                  print(f"[OK] {desc}")

          def remove_line_by_regex(p: Path, pat: str, desc: str):
              s = read(p)
              new, n = re.subn(pat, "", s, flags=re.M)
              if n == 0:
                  print(f"[WARN] {desc}: line not found in {p}, skip")
              else:
                  write(p, new)
                  print(f"[OK] {desc}")

          # 1) AboutFragment：删 donate 对应的 addItem(...) 整块（不依赖具体结构）
          about = Path("app/src/main/java/io/nekohasekai/sagernet/ui/AboutFragment.kt")
          remove_additem_block_containing(about, "R.string.donate", "Remove donate item in AboutFragment")

          # 2) drawer 菜单：删 推广/文档 两项
          menu = Path("app/src/main/res/menu/main_drawer_menu.xml")
          remove_menu_item(menu, "nav_tuiguang", "Remove nav_tuiguang from drawer menu")
          remove_menu_item(menu, "nav_faq", "Remove nav_faq from drawer menu")

          # 3) MainActivity：删处理分支 + 可见性控制行
          main = Path("app/src/main/java/io/nekohasekai/sagernet/ui/MainActivity.kt")
          remove_when_case_block(main, "nav_faq", "Remove nav_faq handler block")
          remove_when_case_block(main, "nav_tuiguang", "Remove nav_tuiguang handler block")
          remove_line_by_regex(
              main,
              r"^[ \t]*navigation\.menu\.findItem\(R\.id\.nav_tuiguang\)\?\.[^\n]*\n",
              "Remove nav_tuiguang visibility line"
          )
          PY
          # ============================================

          # 记录同步到的 release tag（用于下次对比，避免无意义编译）
          echo "$TAG" > .upstream_release_tag

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Sync upstream release $TAG + apply UI patches" || true

          # 强制更新 patched-release（因为 reset 到 tag）
          git push --force-with-lease origin HEAD:patched-release

      - name: Trigger build workflow (only when updated)
        if: steps.upstream.outputs.tag != steps.current.outputs.tag
        run: |
          set -e
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-patched-release.yml/dispatches \
            -d '{"ref":"main"}' >/dev/null
          echo "Build workflow dispatched."
