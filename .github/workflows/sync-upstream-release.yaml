name: Sync Upstream Release (Only When Updated)

on:
  workflow_dispatch:
    inputs:
      force:
        description: "Force re-sync & re-apply patches even if tag unchanged"
        required: false
        default: "false"
  schedule:
    - cron: "0 */6 * * *" # 每6小时检查一次；想更省就改成每天一次：0 3 * * *

permissions:
  contents: write
  actions: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release
          fetch-depth: 0

      - name: Get upstream latest release tag
        id: upstream
        run: |
          set -e
          TAG=$(curl -s https://api.github.com/repos/MatsuriDayo/NekoBoxForAndroid/releases/latest | jq -r .tag_name)
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Upstream latest tag: $TAG"

      - name: Read current synced tag (from patched-release)
        id: current
        run: |
          set -e
          if [ -f .upstream_release_tag ]; then
            CUR=$(cat .upstream_release_tag)
          else
            CUR=""
          fi
          echo "tag=$CUR" >> $GITHUB_OUTPUT
          echo "Current tag: $CUR"

      - name: Exit if no update
        if: steps.upstream.outputs.tag == steps.current.outputs.tag && inputs.force != 'true'
        run: echo "No new upstream release tag. Skip sync & build."

      - name: Sync upstream tag -> patched-release, then apply UI changes
        if: steps.upstream.outputs.tag != steps.current.outputs.tag || inputs.force == 'true'
        run: |
          set -e

          git remote add upstream https://github.com/MatsuriDayo/NekoBoxForAndroid.git || true
          git fetch upstream --tags --force

          TAG="${{ steps.upstream.outputs.tag }}"
          echo "Syncing to tag: $TAG"

          # 让 patched-release 变成“上游发布版源码”
          git reset --hard "refs/tags/$TAG"

          # ====== 自动应用你的 UI 改动（稳健版）======
          python3 - <<'PY'
          import re
          from pathlib import Path

          def read(p: Path) -> str:
              return p.read_text(encoding="utf-8")

          def write(p: Path, s: str):
              p.write_text(s, encoding="utf-8")

          def remove_additem_block_containing(p: Path, needle: str, desc: str):
              s = read(p)
              i = s.find(needle)
              if i == -1:
                  raise SystemExit(f"[FAIL] {desc}: needle not found: {needle} in {p}")

              call = s.rfind("addItem(", 0, i)
              if call == -1:
                  raise SystemExit(f"[FAIL] {desc}: addItem( not found before needle in {p}")

              line_start = s.rfind("\n", 0, call)
              line_start = 0 if line_start == -1 else line_start + 1

              open_idx = s.find("(", call)
              depth = 0
              end = None
              for j in range(open_idx, len(s)):
                  c = s[j]
                  if c == "(":
                      depth += 1
                  elif c == ")":
                      depth -= 1
                      if depth == 0:
                          end = j + 1
                          break
              if end is None:
                  raise SystemExit(f"[FAIL] {desc}: cannot find matching ')' for addItem( in {p}")

              new = s[:line_start] + s[end:]
              write(p, new)
              print(f"[OK] {desc}")

          def remove_menu_items_everywhere(menu_dir: Path, item_ids: list[str]):
              if not menu_dir.exists():
                  print(f"[WARN] menu dir not found: {menu_dir}")
                  return
              for xml in menu_dir.rglob("*.xml"):
                  s = read(xml)
                  orig = s
                  for item_id in item_ids:
                      pat = rf"<item\b[^>]*android:id=\"@\\+id/{re.escape(item_id)}\"[^>]*/>\s*"
                      s = re.sub(pat, "", s, flags=re.S)
                  if s != orig:
                      write(xml, s)
                      print(f"[OK] Removed menu items in {xml}")

          # 关键修复：按 { } 配对删除 when case，避免正则删坏 Kotlin
          def remove_when_case_block_by_braces(p: Path, rid: str, desc: str):
              s = read(p)
              key = f"R.id.{rid}"
              i = s.find(key)
              if i == -1:
                  print(f"[WARN] {desc}: not found ({key}) in {p}, skip")
                  return

              line_start = s.rfind("\n", 0, i)
              line_start = 0 if line_start == -1 else line_start + 1

              arrow = s.find("->", i)
              if arrow == -1:
                  raise SystemExit(f"[FAIL] {desc}: '->' not found after {key} in {p}")

              brace = s.find("{", arrow)
              if brace == -1:
                  # 罕见情况：没用大括号包裹，直接删到行尾
                  line_end = s.find("\n", arrow)
                  line_end = len(s) if line_end == -1 else line_end + 1
                  new = s[:line_start] + s[line_end:]
                  write(p, new)
                  print(f"[OK] {desc} (line form)")
                  return

              depth = 0
              end = None
              for j in range(brace, len(s)):
                  c = s[j]
                  if c == "{":
                      depth += 1
                  elif c == "}":
                      depth -= 1
                      if depth == 0:
                          end = j + 1
                          break
              if end is None:
                  raise SystemExit(f"[FAIL] {desc}: cannot match braces for {key} in {p}")

              # 吃掉一点尾部空白/换行，避免留下奇怪空行
              while end < len(s) and s[end] in " \t\r\n":
                  if s[end] == "\n":
                      end += 1
                      break
                  end += 1

              new = s[:line_start] + s[end:]
              write(p, new)
              print(f"[OK] {desc}")

          def remove_line_by_regex(p: Path, pat: str, desc: str):
              s = read(p)
              new, n = re.subn(pat, "", s, flags=re.M)
              if n == 0:
                  print(f"[WARN] {desc}: line not found in {p}, skip")
              else:
                  write(p, new)
                  print(f"[OK] {desc}")

          # 1) AboutFragment：删 donate 块
          about = Path("app/src/main/java/io/nekohasekai/sagernet/ui/AboutFragment.kt")
          remove_additem_block_containing(about, "R.string.donate", "Remove donate item in AboutFragment")

          # 2) drawer 菜单：在所有 res/menu 里删 nav_tuiguang/nav_faq（若上游换id会 WARN，不影响编译）
          remove_menu_items_everywhere(Path("app/src/main/res/menu"), ["nav_tuiguang", "nav_faq"])

          # 3) MainActivity：删处理分支 + 可见性控制行（这里用括号配对，最稳）
          main = Path("app/src/main/java/io/nekohasekai/sagernet/ui/MainActivity.kt")
          remove_when_case_block_by_braces(main, "nav_faq", "Remove nav_faq handler block")
          remove_when_case_block_by_braces(main, "nav_tuiguang", "Remove nav_tuiguang handler block")
          remove_line_by_regex(
              main,
              r"^[ \t]*navigation\.menu\.findItem\(R\.id\.nav_tuiguang\)\?\.[^\n]*\n",
              "Remove nav_tuiguang visibility line"
          )
          PY
          # ============================================

          # 关键：patched-release 不允许由 GITHUB_TOKEN 推送/更新 workflow 文件，直接删掉
          rm -rf .github/workflows || true

          # 记录同步到的 release tag（用于下次对比）
          echo "$TAG" > .upstream_release_tag

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "Sync upstream release $TAG + apply UI patches" || true

          git push --force-with-lease origin HEAD:patched-release

      - name: Trigger build workflow (only when updated)
        if: steps.upstream.outputs.tag != steps.current.outputs.tag || inputs.force == 'true'
        run: |
          set -e
          curl -s -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/build-patched-release.yml/dispatches \
            -d '{"ref":"main"}' >/dev/null
          echo "Build workflow dispatched."
