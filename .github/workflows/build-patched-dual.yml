name: Build Dual APKs (Signed) + Publish Release

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  TZ: Asia/Shanghai

jobs:
  libcore:
    name: Native Build (LibCore)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release

      - name: Golang Status
        run: find buildScript libcore/*.sh | xargs cat | sha1sum > golang_status

      - name: Libcore Status
        run: git ls-files libcore | xargs cat | sha1sum > libcore_status

      - name: LibCore Cache
        id: cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: libcore-${{ hashFiles('.github/workflows/*.yml', '.github/workflows/*.yaml', 'golang_status', 'libcore_status') }}

      - name: Install Golang
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/setup-go@v5
        with:
          go-version: ^1.25

      - name: Native Build
        if: steps.cache.outputs.cache-hit != 'true'
        run: ./run lib core

  build:
    name: Build Dual APKs (Signed) + Publish Release
    runs-on: ubuntu-latest
    needs: [libcore]
    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release

      - name: Golang Status
        run: find buildScript libcore/*.sh | xargs cat | sha1sum > golang_status

      - name: Libcore Status
        run: git ls-files libcore | xargs cat | sha1sum > libcore_status

      - name: LibCore Cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: libcore-${{ hashFiles('.github/workflows/*.yml', '.github/workflows/*.yaml', 'golang_status', 'libcore_status') }}

      - name: Gradle cache
        uses: actions/cache@v4
        with:
          path: ~/.gradle
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle.kts', '**/gradle-wrapper.properties') }}

      - name: Init Gradle (project scripts)
        env:
          BUILD_PLUGIN: none
        run: |
          set -euo pipefail
          echo "sdk.dir=${ANDROID_HOME}" > local.properties
          echo "ndk.dir=${ANDROID_HOME}/ndk/25.0.8775105" >> local.properties
          export LOCAL_PROPERTIES="${{ secrets.LOCAL_PROPERTIES }}"
          ./run init action gradle

      - name: Build (PreviewRelease / OssRelease)
        env:
          BUILD_PLUGIN: none
        run: |
          set -euo pipefail
          ./gradlew app:assemblePreviewRelease app:assembleOssRelease

      - name: Prepare signing keystore (PKCS12)
        env:
          SIGNING_KEYSTORE_B64: ${{ secrets.SIGNING_KEYSTORE_B64 }}
        run: |
          set -euo pipefail
          echo "$SIGNING_KEYSTORE_B64" | base64 -d > signing.p12
          ls -lah signing.p12

      - name: Validate keystore (fail fast)
        env:
          STOREPASS: ${{ secrets.SIGNING_KEYSTORE_PASSWORD }}
          KEYALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
        run: |
          set -euo pipefail
          keytool -list -v \
            -keystore signing.p12 \
            -storetype PKCS12 \
            -storepass "$STOREPASS" \
            -alias "$KEYALIAS" >/dev/null
          echo "Keystore OK (alias exists)."

      - name: Collect + Sign APKs -> dist/ (rename nicely)
        env:
          STOREPASS: ${{ secrets.SIGNING_KEYSTORE_PASSWORD }}
          KEYALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
          KEYPASS: ${{ secrets.SIGNING_KEY_PASSWORD }}
        run: |
          set -euo pipefail
          mkdir -p dist

          # Read upstream tag if available (from sync workflow), else fallback
          UPSTREAM_TAG="unknown"
          if [ -f ".upstream_release_tag" ]; then
            UPSTREAM_TAG="$(cat .upstream_release_tag | tr -d '\r\n' | xargs)"
          else
            UPSTREAM_TAG="$(git describe --tags --abbrev=0 2>/dev/null || echo unknown)"
          fi
          echo "UPSTREAM_TAG=$UPSTREAM_TAG" >> $GITHUB_ENV
          echo "Upstream tag: $UPSTREAM_TAG"

          # Find latest build-tools apksigner
          BUILD_TOOLS="$(ls -1 "${ANDROID_HOME}/build-tools" | sort -V | tail -n 1)"
          APKSIGNER="${ANDROID_HOME}/build-tools/${BUILD_TOOLS}/apksigner"
          echo "Using build-tools: ${BUILD_TOOLS}"
          "${APKSIGNER}" version || true

          sign_one() {
            local in_apk="$1"
            local channel="$2"   # preview | oss
            local arch="$3"      # arm64-v8a | armeabi-v7a | x86 | x86_64
            local out_apk="dist/NekoBox-${UPSTREAM_TAG}-${channel}-${arch}-signed.apk"

            echo "Signing: $in_apk"
            "${APKSIGNER}" sign \
              --ks signing.p12 \
              --ks-type PKCS12 \
              --ks-pass "pass:${STOREPASS}" \
              --ks-key-alias "${KEYALIAS}" \
              --key-pass "pass:${KEYPASS}" \
              --out "${out_apk}" \
              "${in_apk}"

            "${APKSIGNER}" verify --verbose --print-certs "${out_apk}" >/dev/null
            echo "OK: ${out_apk}"
          }

          detect_arch() {
            local name="$1"
            if echo "$name" | grep -q "arm64-v8a"; then echo "arm64-v8a"; return; fi
            if echo "$name" | grep -q "armeabi-v7a"; then echo "armeabi-v7a"; return; fi
            if echo "$name" | grep -q "x86_64"; then echo "x86_64"; return; fi
            if echo "$name" | grep -qE "(^|[^_])x86([^_]|$)"; then echo "x86"; return; fi
            echo "unknown"
          }

          SIGNED_COUNT=0

          # 1) Preview release outputs
          if [ -d "app/build/outputs/apk/preview/release" ]; then
            while IFS= read -r apk; do
              [ -f "$apk" ] || continue
              arch="$(detect_arch "$(basename "$apk")")"
              sign_one "$apk" "preview" "$arch"
              SIGNED_COUNT=$((SIGNED_COUNT+1))
            done < <(find app/build/outputs/apk/preview/release -type f -name "*.apk" | sort)
          else
            echo "WARN: preview/release output dir not found"
          fi

          # 2) OSS stable release outputs
          if [ -d "app/build/outputs/apk/oss/release" ]; then
            while IFS= read -r apk; do
              [ -f "$apk" ] || continue
              arch="$(detect_arch "$(basename "$apk")")"
              sign_one "$apk" "oss" "$arch"
              SIGNED_COUNT=$((SIGNED_COUNT+1))
            done < <(find app/build/outputs/apk/oss/release -type f -name "*.apk" | sort)
          else
            echo "WARN: oss/release output dir not found"
          fi

          echo "Signed count = $SIGNED_COUNT"
          ls -lah dist || true

          if [ "$SIGNED_COUNT" -eq 0 ]; then
            echo "ERROR: No APKs signed. dist is empty."
            echo "DEBUG: list app/build/outputs/apk:"
            find app/build/outputs/apk -maxdepth 6 -type f -name "*.apk" -print || true
            exit 1
          fi

          echo "DIST_DIR=$(pwd)/dist" >> $GITHUB_ENV

      - name: Upload APKs (Artifacts)
        uses: actions/upload-artifact@v4
        with:
          name: APKs
          path: dist/*.apk

      - name: Publish GitHub Release (both variants)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          UPSTREAM_TAG="${UPSTREAM_TAG:-unknown}"
          TS="$(date +'%Y%m%d-%H%M')"
          TAG="patched-${UPSTREAM_TAG}+build-${TS}"
          TITLE="Patched ${UPSTREAM_TAG} (${TS} CST)"

          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "RELEASE_TITLE=$TITLE" >> $GITHUB_ENV

          # create release via gh (preinstalled on ubuntu-latest)
          gh release create "$TAG" dist/*.apk \
            --title "$TITLE" \
            --notes "Upstream: ${UPSTREAM_TAG}
Patched branch: patched-release
Commit: $(git rev-parse --short HEAD)

Artifacts:
- Preview (signed): NekoBox-${UPSTREAM_TAG}-preview-*-signed.apk
- OSS Stable (signed): NekoBox-${UPSTREAM_TAG}-oss-*-signed.apk" \
            --latest
