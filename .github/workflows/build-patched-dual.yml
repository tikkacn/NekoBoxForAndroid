name: Build Patched Dual (Signed)

on:
  workflow_dispatch:

jobs:
  libcore:
    name: Native Build (LibCore)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release

      - name: Golang Status
        run: find buildScript libcore/*.sh | xargs cat | sha1sum > golang_status

      - name: Libcore Status
        run: git ls-files libcore | xargs cat | sha1sum > libcore_status

      - name: LibCore Cache
        id: cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: ${{ hashFiles('.github/workflows/*', 'golang_status', 'libcore_status') }}

      - name: Install Golang
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/setup-go@v5
        with:
          go-version: ^1.25

      - name: Native Build
        if: steps.cache.outputs.cache-hit != 'true'
        run: ./run lib core

  build:
    name: Build Dual APKs (Signed)
    runs-on: ubuntu-latest
    needs: [libcore]
    env:
      TZ: Asia/Shanghai
      BUILD_PLUGIN: none

      # ====== SIGNING (match your repo secrets) ======
      KSTYPE: JKS
      KEYSTORE_B64: ${{ secrets.SIGNING_KEYSTORE_B64 }}
      STORE_PASS: ${{ secrets.SIGNING_KEYSTORE_PASSWORD }}
      KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
      KEY_PASS: ${{ secrets.SIGNING_KEY_PASSWORD }}

    steps:
      - name: Checkout patched-release
        uses: actions/checkout@v4
        with:
          ref: patched-release

      - name: Golang Status
        run: find buildScript libcore/*.sh | xargs cat | sha1sum > golang_status

      - name: Libcore Status
        run: git ls-files libcore | xargs cat | sha1sum > libcore_status

      - name: LibCore Cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: ${{ hashFiles('.github/workflows/*', 'golang_status', 'libcore_status') }}

      - name: Gradle cache
        uses: actions/cache@v4
        with:
          path: ~/.gradle
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle.kts') }}

      - name: Prepare signing keystore (JKS)
        shell: bash
        run: |
          set -euo pipefail
          [ -n "${KEYSTORE_B64}" ] || (echo "ERROR: SIGNING_KEYSTORE_B64 is empty" && exit 1)
          [ -n "${STORE_PASS}" ]  || (echo "ERROR: SIGNING_KEYSTORE_PASSWORD is empty" && exit 1)
          [ -n "${KEY_ALIAS}" ]   || (echo "ERROR: SIGNING_KEY_ALIAS is empty" && exit 1)
          [ -n "${KEY_PASS}" ]    || (echo "ERROR: SIGNING_KEY_PASSWORD is empty" && exit 1)

          KEYSTORE="${RUNNER_TEMP}/signing.jks"
          printf '%s' "${KEYSTORE_B64}" | tr -d '\r\n' | base64 -d > "${KEYSTORE}"
          echo "KEYSTORE=${KEYSTORE}" >> $GITHUB_ENV
          ls -lah "${KEYSTORE}"

      - name: Validate keystore (fail fast)
        shell: bash
        run: |
          set -euo pipefail
          keytool -list \
            -keystore "${KEYSTORE}" \
            -storetype "${KSTYPE}" \
            -storepass "${STORE_PASS}" \
            -alias "${KEY_ALIAS}" >/dev/null
          echo "Keystore OK (alias exists)."

      - name: Init Gradle (project scripts)
        shell: bash
        run: |
          set -euo pipefail
          echo "sdk.dir=${ANDROID_HOME}" > local.properties
          echo "ndk.dir=${ANDROID_HOME}/ndk/25.0.8775105" >> local.properties
          ./run init action gradle

      - name: Build (PreviewRelease + OssRelease)
        shell: bash
        run: |
          set -euo pipefail
          ./gradlew app:assemblePreviewRelease app:assembleOssRelease

      - name: Sign APKs -> dist/
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p dist

          BUILD_TOOLS="$(ls -d ${ANDROID_HOME}/build-tools/* | sort -V | tail -n 1)"
          APKSIGNER="${BUILD_TOOLS}/apksigner"
          echo "Using build-tools: ${BUILD_TOOLS}"

          sign_one () {
            local in_apk="$1"
            local base="$(basename "$in_apk")"
            local out_apk="dist/${base/-unsigned/}"
            if [ "$out_apk" = "dist/${base}" ]; then
              out_apk="dist/signed-${base}"
            fi

            "${APKSIGNER}" sign \
              --ks "${KEYSTORE}" \
              --ks-type "${KSTYPE}" \
              --ks-key-alias "${KEY_ALIAS}" \
              --ks-pass "pass:${STORE_PASS}" \
              --key-pass "pass:${KEY_PASS}" \
              --out "${out_apk}" \
              "${in_apk}"

            "${APKSIGNER}" verify --verbose "${out_apk}" >/dev/null
            echo "SIGNED: ${out_apk}"
          }

          SIGNED_COUNT=0

          if [ -d "app/build/outputs/apk/preview/release" ]; then
            while IFS= read -r apk; do
              [ -f "$apk" ] || continue
              sign_one "$apk"
              SIGNED_COUNT=$((SIGNED_COUNT+1))
            done < <(find app/build/outputs/apk/preview/release -type f -name "*.apk" | sort)
          else
            echo "WARN: preview/release output dir not found"
          fi

          if [ -d "app/build/outputs/apk/oss/release" ]; then
            while IFS= read -r apk; do
              [ -f "$apk" ] || continue
              sign_one "$apk"
              SIGNED_COUNT=$((SIGNED_COUNT+1))
            done < <(find app/build/outputs/apk/oss/release -type f -name "*.apk" | sort)
          else
            echo "WARN: oss/release output dir not found"
          fi

          echo "Signed count = $SIGNED_COUNT"
          ls -lah dist || true

          if [ "$SIGNED_COUNT" -eq 0 ]; then
            echo "ERROR: No APKs signed. dist is empty."
            find app/build/outputs/apk -maxdepth 6 -type f -name "*.apk" -print || true
            exit 1
          fi

      - name: Upload signed APKs
        uses: actions/upload-artifact@v4
        with:
          name: signed-apks
          path: dist/*.apk
