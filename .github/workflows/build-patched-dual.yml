name: Build Patched Dual (Preview + Stable, Signed)

on:
  workflow_dispatch:
    inputs:
      target_ref:
        description: "Code branch to build (should contain your UI patches)"
        required: false
        default: "patched-release"
      publish_release:
        description: "Publish GitHub Release? (y/n)"
        required: false
        default: "n"
      release_tag:
        description: "Override release tag (leave empty for auto)"
        required: false
        default: ""
      build_preview:
        description: "Build PreviewRelease? (y/n)"
        required: false
        default: "y"
      build_stable:
        description: "Build OssRelease (stable)? (y/n)"
        required: false
        default: "y"

permissions:
  contents: write

jobs:
  libcore:
    name: Native Build (LibCore)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_ref }}
          fetch-depth: 0

      - name: Golang Status
        run: find buildScript libcore/*.sh | xargs cat | sha1sum > golang_status

      - name: Libcore Status
        run: git ls-files libcore | xargs cat | sha1sum > libcore_status

      - name: LibCore Cache
        id: cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: libcore-${{ runner.os }}-${{ hashFiles('.github/workflows/*', 'golang_status', 'libcore_status') }}

      - name: Install Golang
        if: steps.cache.outputs.cache-hit != 'true'
        uses: actions/setup-go@v5
        with:
          go-version: ^1.25

      - name: Native Build
        if: steps.cache.outputs.cache-hit != 'true'
        run: ./run lib core

  build:
    name: Build Dual APKs (Signed)
    runs-on: ubuntu-latest
    needs: [libcore]
    steps:
      - name: Checkout target branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_ref }}
          fetch-depth: 0

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Restore LibCore Cache
        uses: actions/cache@v4
        with:
          path: app/libs/libcore.aar
          key: libcore-${{ runner.os }}-${{ hashFiles('.github/workflows/*', 'golang_status', 'libcore_status') }}

      - name: Gradle cache
        uses: actions/cache@v4
        with:
          path: ~/.gradle
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle.kts', '**/gradle.properties', '**/gradle-wrapper.properties') }}

      - name: Prepare signing keystore (p12)
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ secrets.SIGNING_STORE_B64 }}" | base64 -d > "$RUNNER_TEMP/signing.p12"
          echo "KEYSTORE=$RUNNER_TEMP/signing.p12" >> $GITHUB_ENV

      - name: Init Gradle (project scripts)
        env:
          BUILD_PLUGIN: none
        shell: bash
        run: |
          set -euo pipefail
          echo "sdk.dir=${ANDROID_HOME}" > local.properties
          echo "ndk.dir=${ANDROID_HOME}/ndk/25.0.8775105" >> local.properties
          export LOCAL_PROPERTIES="${{ secrets.LOCAL_PROPERTIES }}"
          ./run init action gradle

      - name: Build (PreviewRelease / OssRelease)
        env:
          BUILD_PLUGIN: none
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.event.inputs.build_preview }}" != "n" ]; then
            ./gradlew app:assemblePreviewRelease
          fi
          if [ "${{ github.event.inputs.build_stable }}" != "n" ]; then
            ./gradlew app:assembleOssRelease
          fi

      - name: Sign APKs (zipalign + apksigner) -> dist/
        shell: bash
        run: |
          set -euo pipefail

          BT="$(ls -d ${ANDROID_HOME}/build-tools/* | sort -V | tail -n 1)"
          ZIPALIGN="$BT/zipalign"
          APKSIGNER="$BT/apksigner"
          echo "Using build-tools: $BT"

          UPSTREAM_TAG="unknown"
          if [ -f ".upstream_release_tag" ]; then
            UPSTREAM_TAG="$(cat .upstream_release_tag | tr -d ' \r\n')"
          fi
          TS="$(TZ=Asia/Shanghai date +%Y%m%d-%H%M)"
          AUTO_TAG="patched-${UPSTREAM_TAG}+build-${TS}"

          FINAL_TAG="${{ github.event.inputs.release_tag }}"
          if [ -z "$FINAL_TAG" ]; then
            FINAL_TAG="$AUTO_TAG"
          fi

          echo "UPSTREAM_TAG=$UPSTREAM_TAG" >> $GITHUB_ENV
          echo "BUILD_TS=$TS" >> $GITHUB_ENV
          echo "RELEASE_TAG=$FINAL_TAG" >> $GITHUB_ENV

          mkdir -p dist

          sign_one () {
            local apk="$1"
            local base="$(basename "$apk")"
            local aligned="dist/${FINAL_TAG}--${base%.apk}--aligned.apk"
            local signed="dist/${FINAL_TAG}--${base%.apk}--SIGNED.apk"

            echo "Signing: $apk"
            "$ZIPALIGN" -p -f 4 "$apk" "$aligned"
            "$APKSIGNER" sign \
              --ks "$KEYSTORE" \
              --ks-key-alias "${{ secrets.SIGNING_KEY_ALIAS }}" \
              --ks-pass "pass:${{ secrets.SIGNING_STORE_PASSWORD }}" \
              --key-pass "pass:${{ secrets.SIGNING_KEY_PASSWORD }}" \
              --out "$signed" \
              "$aligned"
            "$APKSIGNER" verify --verbose "$signed"
            rm -f "$aligned"
            echo "OK: $signed"
          }

          SIGNED_COUNT=0

          # 1) Preview release outputs
          if [ "${{ github.event.inputs.build_preview }}" != "n" ]; then
            if [ -d "app/build/outputs/apk/preview/release" ]; then
              while IFS= read -r apk; do
                [ -f "$apk" ] || continue
                sign_one "$apk"
                SIGNED_COUNT=$((SIGNED_COUNT+1))
              done < <(find app/build/outputs/apk/preview/release -type f -name "*.apk" | sort)
            else
              echo "WARN: preview/release output dir not found"
            fi
          fi

          # 2) OSS stable release outputs
          if [ "${{ github.event.inputs.build_stable }}" != "n" ]; then
            if [ -d "app/build/outputs/apk/oss/release" ]; then
              while IFS= read -r apk; do
                [ -f "$apk" ] || continue
                sign_one "$apk"
                SIGNED_COUNT=$((SIGNED_COUNT+1))
              done < <(find app/build/outputs/apk/oss/release -type f -name "*.apk" | sort)
            else
              echo "WARN: oss/release output dir not found"
            fi
          fi

          echo "Signed count = $SIGNED_COUNT"
          ls -lah dist || true

          if [ "$SIGNED_COUNT" -eq 0 ]; then
            echo "ERROR: No APKs signed. dist is empty."
            echo "DEBUG: list app/build/outputs/apk:"
            find app/build/outputs/apk -maxdepth 4 -type f -name "*.apk" -print || true
            exit 1
          fi

          echo "DIST_DIR=$(pwd)/dist" >> $GITHUB_ENV

      - name: Upload signed APKs (artifact)
        uses: actions/upload-artifact@v4
        with:
          name: APKs-${{ env.RELEASE_TAG }}
          path: dist/*.apk

      - name: Publish GitHub Release (optional)
        if: ${{ github.event.inputs.publish_release == 'y' }}
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail
          gh release create "${RELEASE_TAG}" dist/*.apk \
            --title "${RELEASE_TAG}" \
            --notes "Upstream: ${UPSTREAM_TAG}\nBuild time (Asia/Shanghai): ${BUILD_TS}\nBranch: ${{ github.event.inputs.target_ref }}"
